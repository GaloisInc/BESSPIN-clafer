// now primitive types can be used as types of references, which may be useful for redefinition
abstract intNumber -> integer

// this is a proper type refinement
numberOne : intNumber -> 1

abstract name -> string

// this is a proper type refinement
alice : name -> "Alice"

abstract realNumber -> real

// these are proper type refinements
pi : realNumber -> 3.1415
piDouble : realNumber -> 3.14e0
piInt : realNumber -> 3

abstract doubleNumber : realNumber -> double
numberTwentyFive : doubleNumber -> 2.5e1

abstract intNumber2 : realNumber -> integer
numberThree : intNumber2 -> 3

abstract intNumber3 : doubleNumber -> integer
numberFour : intNumber2 -> 4

likertScaleVal -> 1, 2, 3, 4, 5

abstract Person
    spouse -> Person ?
    abstract Head

Alice : Person
    h : Head

Ella : Person
    h : Head

// but primitive types cannot be used as super types (triggers parse error)
// n : 1
// s : "Alice"
// d : 3.1415

// however, now we can use . as super type expressions
abstract Team
  abstract Member

team1 : Team
  Bob : Team.Member

spouse -> Alice

// expressions now allowed as reference target
spouseIf -> if (1 > 0) then Alice else Ella  *

spouseUnion -> Alice ++ Ella *

spouseIntersection -> Alice ** Person *

spouseDifference -> Person -- Ella *

spouseDomain -> Alice <: spouse *

spouseRange -> spouse :> Ella *

spouseJoin -> Person.spouse *

heads -> Person.Head *

// but these expressions are not allowed as a super type (triggers parse error)
// AliceOrElla : if (1 > 0) then Alice else Ella
