{-
 This file is part of the Clafer Translator (clafer).

 Copyright (C) 2010 Kacper Bak <http://gsd.uwaterloo.ca/kbak>

 clafer is free software: you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 clafer is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with clafer. (See files COPYING and COPYING.LESSER.)  If not,
 see <http://www.gnu.org/licenses/>.
-}
module Generator.XmlHelp where

import Data.List (isPrefixOf)
import Text.XML.HaXml.XmlContent.Haskell
import Front.Absclafer
import Intermediate.Intclafer
{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "Front/Absclafer.hs" #-}
{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance HTypeable ExInteger where
    toHType v =
	Defined "ExInteger" []
		[Constr "ExIntegerAst" [] [],Constr "ExIntegerNum" [] [toHType aa]]
      where
	(ExIntegerNum aa) = v
instance XmlContent ExInteger where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["ExIntegerNum","ExIntegerAst"]
	; case t of
	  _ | "ExIntegerNum" `isPrefixOf` t -> interior e $ fmap ExIntegerNum parseContents
	    | "ExIntegerAst" `isPrefixOf` t -> interior e $ return ExIntegerAst
	}
    toContents v@ExIntegerAst =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@(ExIntegerNum aa) =
	[mkElemC (showConstr 1 (toHType v)) (toContents aa)]

instance HTypeable Quant where
    toHType v =
	Defined "Quant" []
		[Constr "QuantNo" [] [],Constr "QuantLone" [] [],
		 Constr "QuantOne" [] [],Constr "QuantSome" [] []]
instance XmlContent Quant where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["QuantSome","QuantOne","QuantNo","QuantLone"]
	; case t of
	  _ | "QuantSome" `isPrefixOf` t -> interior e $ return QuantSome
	    | "QuantOne" `isPrefixOf` t -> interior e $ return QuantOne
	    | "QuantNo" `isPrefixOf` t -> interior e $ return QuantNo
	    | "QuantLone" `isPrefixOf` t -> interior e $ return QuantLone
	}
    toContents v@QuantNo =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@QuantLone =
	[mkElemC (showConstr 1 (toHType v)) []]
    toContents v@QuantOne =
	[mkElemC (showConstr 2 (toHType v)) []]
    toContents v@QuantSome =
	[mkElemC (showConstr 3 (toHType v)) []]

instance HTypeable ExQuant where
    toHType v =
	Defined "ExQuant" []
		[Constr "ExQuantAll" [] [],Constr "ExQuant" [] [toHType aa]]
      where
	(ExQuant aa) = v
instance XmlContent ExQuant where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["ExQuantAll","ExQuant"]
	; case t of
	  _ | "ExQuantAll" `isPrefixOf` t -> interior e $ return ExQuantAll
	    | "ExQuant" `isPrefixOf` t -> interior e $ fmap ExQuant parseContents
	}
    toContents v@ExQuantAll =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@(ExQuant aa) =
	[mkElemC (showConstr 1 (toHType v)) (toContents aa)]

instance HTypeable StrExp where
    toHType v =
	Defined "StrExp" []
		[Constr "EConc" [] [toHType aa,toHType ab],
		 Constr "EStr" [] [toHType ac]]
      where
	(EConc aa ab) = v
	(EStr ac) = v
instance XmlContent StrExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["EStr","EConc"]
	; case t of
	  _ | "EStr" `isPrefixOf` t -> interior e $ fmap EStr parseContents
	    | "EConc" `isPrefixOf` t -> interior e $
		    return EConc `apply` parseContents `apply` parseContents
	}
    toContents v@(EConc aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(EStr ac) =
	[mkElemC (showConstr 1 (toHType v)) (toContents ac)]

--  Imported from other files :-
{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "Intermediate/Intclafer.hs" #-}
{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance HTypeable EType where
    toHType v =
	Defined "EType" []
		[Constr "TAExp" [] [],Constr "TSExp" [] [],Constr "TSAExp" [] []]
instance XmlContent EType where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["TSExp","TSAExp","TAExp"]
	; case t of
	  _ | "TSExp" `isPrefixOf` t -> interior e $ return TSExp
	    | "TSAExp" `isPrefixOf` t -> interior e $ return TSAExp
	    | "TAExp" `isPrefixOf` t -> interior e $ return TAExp
	}
    toContents v@TAExp =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@TSExp =
	[mkElemC (showConstr 1 (toHType v)) []]
    toContents v@TSAExp =
	[mkElemC (showConstr 2 (toHType v)) []]

instance HTypeable IDeclaration where
    toHType v =
	Defined "IDeclaration" []
		[Constr "IClaferDecl" [] [toHType aa],
		 Constr "IConstDecl" [] [toHType ab]]
      where
	(IClaferDecl aa) = v
	(IConstDecl ab) = v
instance XmlContent IDeclaration where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["IConstDecl","IClaferDecl"]
	; case t of
	  _ | "IConstDecl" `isPrefixOf` t -> interior e $ fmap IConstDecl parseContents
	    | "IClaferDecl" `isPrefixOf` t -> interior e $ fmap IClaferDecl parseContents
	}
    toContents v@(IClaferDecl aa) =
	[mkElemC (showConstr 0 (toHType v)) (toContents aa)]
    toContents v@(IConstDecl ab) =
	[mkElemC (showConstr 1 (toHType v)) (toContents ab)]

instance HTypeable IClafer where
    toHType v =
	Defined "IClafer" []
		[Constr "IClafer" []
			[toHType aa,toHType ab,toHType ac,toHType ad,toHType ae,toHType af,
			 toHType ag,toHType ah]]
      where
	(IClafer aa ab ac ad ae af ag ah) = v
instance XmlContent IClafer where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "IClafer" $
		return IClafer `apply` parseContents `apply` parseContents
			       `apply` parseContents `apply` parseContents `apply` parseContents
			       `apply` parseContents `apply` parseContents `apply` parseContents
	}
    toContents v@(IClafer aa ab ac ad ae af ag ah) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab,toContents ac,toContents ad,
						     toContents ae,toContents af,toContents ag,
						     toContents ah])]

instance HTypeable IElement where
    toHType v =
	Defined "IElement" []
		[Constr "ISubclafer" [] [toHType aa],
		 Constr "ISubconstraint" [] [toHType ab]]
      where
	(ISubclafer aa) = v
	(ISubconstraint ab) = v
instance XmlContent IElement where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["ISubconstraint","ISubclafer"]
	; case t of
	  _ | "ISubconstraint" `isPrefixOf` t -> interior e $ fmap ISubconstraint parseContents
	    | "ISubclafer" `isPrefixOf` t -> interior e $ fmap ISubclafer parseContents
	}
    toContents v@(ISubclafer aa) =
	[mkElemC (showConstr 0 (toHType v)) (toContents aa)]
    toContents v@(ISubconstraint ab) =
	[mkElemC (showConstr 1 (toHType v)) (toContents ab)]

instance HTypeable ISuper where
    toHType v =
	Defined "ISuper" [] [Constr "ISuper" [] [toHType aa,toHType ab]]
      where
	(ISuper aa ab) = v
instance XmlContent ISuper where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "ISuper" $
		return ISuper `apply` parseContents `apply` parseContents
	}
    toContents v@(ISuper aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]

instance HTypeable IGCard where
    toHType v =
	Defined "IGCard" [] [Constr "IGCard" [] [toHType aa,toHType ab]]
      where
	(IGCard aa ab) = v
instance XmlContent IGCard where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "IGCard" $
		return IGCard `apply` parseContents `apply` parseContents
	}
    toContents v@(IGCard aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]

instance HTypeable ILExp where
    toHType v =
	Defined "ILExp" []
		[Constr "IEIff" [] [toHType aa,toHType ab],
		 Constr "IEImpliesElse" [] [toHType ac,toHType ad,toHType ae],
		 Constr "IEOr" [] [toHType af,toHType ag],
		 Constr "IEXor" [] [toHType ah,toHType ai],
		 Constr "IEAnd" [] [toHType aj,toHType ak],
		 Constr "IENeg" [] [toHType al],Constr "IETerm" [] [toHType am]]
      where
	(IEIff aa ab) = v
	(IEImpliesElse ac ad ae) = v
	(IEOr af ag) = v
	(IEXor ah ai) = v
	(IEAnd aj ak) = v
	(IENeg al) = v
	(IETerm am) = v
instance XmlContent ILExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["IEXor","IETerm","IEOr","IENeg","IEImpliesElse","IEIff","IEAnd"]
	; case t of
	  _ | "IEXor" `isPrefixOf` t -> interior e $
		    return IEXor `apply` parseContents `apply` parseContents
	    | "IETerm" `isPrefixOf` t -> interior e $ fmap IETerm parseContents
	    | "IEOr" `isPrefixOf` t -> interior e $
		    return IEOr `apply` parseContents `apply` parseContents
	    | "IENeg" `isPrefixOf` t -> interior e $ fmap IENeg parseContents
	    | "IEImpliesElse" `isPrefixOf` t -> interior e $
		    return IEImpliesElse `apply` parseContents `apply` parseContents
					 `apply` parseContents
	    | "IEIff" `isPrefixOf` t -> interior e $
		    return IEIff `apply` parseContents `apply` parseContents
	    | "IEAnd" `isPrefixOf` t -> interior e $
		    return IEAnd `apply` parseContents `apply` parseContents
	}
    toContents v@(IEIff aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(IEImpliesElse ac ad ae) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ac,
						     toContents ad,toContents ae])]
    toContents v@(IEOr af ag) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents af,
						     toContents ag])]
    toContents v@(IEXor ah ai) =
	[mkElemC (showConstr 3 (toHType v)) (concat [toContents ah,
						     toContents ai])]
    toContents v@(IEAnd aj ak) =
	[mkElemC (showConstr 4 (toHType v)) (concat [toContents aj,
						     toContents ak])]
    toContents v@(IENeg al) =
	[mkElemC (showConstr 5 (toHType v)) (toContents al)]
    toContents v@(IETerm am) =
	[mkElemC (showConstr 6 (toHType v)) (toContents am)]

instance HTypeable ITerm where
    toHType v =
	Defined "ITerm" []
		[Constr "ITermCmpExp" [] [toHType aa,toHType ab],
		 Constr "ITermQuantSet" [] [toHType ac,toHType ad],
		 Constr "ITermQuantDeclExp" [] [toHType ae,toHType af]]
      where
	(ITermCmpExp aa ab) = v
	(ITermQuantSet ac ad) = v
	(ITermQuantDeclExp ae af) = v
instance XmlContent ITerm where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["ITermQuantSet","ITermQuantDeclExp","ITermCmpExp"]
	; case t of
	  _ | "ITermQuantSet" `isPrefixOf` t -> interior e $
		    return ITermQuantSet `apply` parseContents `apply` parseContents
	    | "ITermQuantDeclExp" `isPrefixOf` t -> interior e $
		    return ITermQuantDeclExp `apply` parseContents
					     `apply` parseContents
	    | "ITermCmpExp" `isPrefixOf` t -> interior e $
		    return ITermCmpExp `apply` parseContents `apply` parseContents
	}
    toContents v@(ITermCmpExp aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(ITermQuantSet ac ad) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ac,
						     toContents ad])]
    toContents v@(ITermQuantDeclExp ae af) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents ae,
						     toContents af])]

instance HTypeable ICmpExp where
    toHType v =
	Defined "ICmpExp" []
		[Constr "IELt" [] [toHType aa,toHType ab],
		 Constr "IEGt" [] [toHType ac,toHType ad],
		 Constr "IEREq" [] [toHType ae,toHType af],
		 Constr "IEEq" [] [toHType ag,toHType ah],
		 Constr "IELte" [] [toHType ai,toHType aj],
		 Constr "IEGte" [] [toHType ak,toHType al],
		 Constr "IENeq" [] [toHType am,toHType an],
		 Constr "IERNeq" [] [toHType ao,toHType ap],
		 Constr "IEIn" [] [toHType aq,toHType ar],
		 Constr "IENin" [] [toHType as,toHType at]]
      where
	(IELt aa ab) = v
	(IEGt ac ad) = v
	(IEREq ae af) = v
	(IEEq ag ah) = v
	(IELte ai aj) = v
	(IEGte ak al) = v
	(IENeq am an) = v
	(IERNeq ao ap) = v
	(IEIn aq ar) = v
	(IENin as at) = v
instance XmlContent ICmpExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["IERNeq","IEREq","IENin","IENeq","IELte","IELt","IEIn","IEGte","IEGt","IEEq"]
	; case t of
	  _ | "IERNeq" `isPrefixOf` t -> interior e $
		    return IERNeq `apply` parseContents `apply` parseContents
	    | "IEREq" `isPrefixOf` t -> interior e $
		    return IEREq `apply` parseContents `apply` parseContents
	    | "IENin" `isPrefixOf` t -> interior e $
		    return IENin `apply` parseContents `apply` parseContents
	    | "IENeq" `isPrefixOf` t -> interior e $
		    return IENeq `apply` parseContents `apply` parseContents
	    | "IELte" `isPrefixOf` t -> interior e $
		    return IELte `apply` parseContents `apply` parseContents
	    | "IELt" `isPrefixOf` t -> interior e $
		    return IELt `apply` parseContents `apply` parseContents
	    | "IEIn" `isPrefixOf` t -> interior e $
		    return IEIn `apply` parseContents `apply` parseContents
	    | "IEGte" `isPrefixOf` t -> interior e $
		    return IEGte `apply` parseContents `apply` parseContents
	    | "IEGt" `isPrefixOf` t -> interior e $
		    return IEGt `apply` parseContents `apply` parseContents
	    | "IEEq" `isPrefixOf` t -> interior e $
		    return IEEq `apply` parseContents `apply` parseContents
	}
    toContents v@(IELt aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(IEGt ac ad) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ac,
						     toContents ad])]
    toContents v@(IEREq ae af) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents ae,
						     toContents af])]
    toContents v@(IEEq ag ah) =
	[mkElemC (showConstr 3 (toHType v)) (concat [toContents ag,
						     toContents ah])]
    toContents v@(IELte ai aj) =
	[mkElemC (showConstr 4 (toHType v)) (concat [toContents ai,
						     toContents aj])]
    toContents v@(IEGte ak al) =
	[mkElemC (showConstr 5 (toHType v)) (concat [toContents ak,
						     toContents al])]
    toContents v@(IENeq am an) =
	[mkElemC (showConstr 6 (toHType v)) (concat [toContents am,
						     toContents an])]
    toContents v@(IERNeq ao ap) =
	[mkElemC (showConstr 7 (toHType v)) (concat [toContents ao,
						     toContents ap])]
    toContents v@(IEIn aq ar) =
	[mkElemC (showConstr 8 (toHType v)) (concat [toContents aq,
						     toContents ar])]
    toContents v@(IENin as at) =
	[mkElemC (showConstr 9 (toHType v)) (concat [toContents as,
						     toContents at])]

instance HTypeable IExp where
    toHType v =
	Defined "IExp" []
		[Constr "IENumExp" [] [toHType aa],
		 Constr "IEStrExp" [] [toHType ab]]
      where
	(IENumExp aa) = v
	(IEStrExp ab) = v
instance XmlContent IExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["IEStrExp","IENumExp"]
	; case t of
	  _ | "IEStrExp" `isPrefixOf` t -> interior e $ fmap IEStrExp parseContents
	    | "IENumExp" `isPrefixOf` t -> interior e $ fmap IENumExp parseContents
	}
    toContents v@(IENumExp aa) =
	[mkElemC (showConstr 0 (toHType v)) (toContents aa)]
    toContents v@(IEStrExp ab) =
	[mkElemC (showConstr 1 (toHType v)) (toContents ab)]

instance HTypeable ISExp where
    toHType v =
	Defined "ISExp" []
		[Constr "ISExpUnion" [] [toHType aa,toHType ab],
		 Constr "ISExpIntersection" [] [toHType ac,toHType ad],
		 Constr "ISExpDomain" [] [toHType ae,toHType af],
		 Constr "ISExpRange" [] [toHType ag,toHType ah],
		 Constr "ISExpJoin" [] [toHType ai,toHType aj],
		 Constr "ISExpIdent" [] [toHType ak,toHType al]]
      where
	(ISExpUnion aa ab) = v
	(ISExpIntersection ac ad) = v
	(ISExpDomain ae af) = v
	(ISExpRange ag ah) = v
	(ISExpJoin ai aj) = v
	(ISExpIdent ak al) = v
instance XmlContent ISExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["ISExpUnion","ISExpRange","ISExpJoin","ISExpIntersection","ISExpIdent","ISExpDomain"]
	; case t of
	  _ | "ISExpUnion" `isPrefixOf` t -> interior e $
		    return ISExpUnion `apply` parseContents `apply` parseContents
	    | "ISExpRange" `isPrefixOf` t -> interior e $
		    return ISExpRange `apply` parseContents `apply` parseContents
	    | "ISExpJoin" `isPrefixOf` t -> interior e $
		    return ISExpJoin `apply` parseContents `apply` parseContents
	    | "ISExpIntersection" `isPrefixOf` t -> interior e $
		    return ISExpIntersection `apply` parseContents
					     `apply` parseContents
	    | "ISExpIdent" `isPrefixOf` t -> interior e $
		    return ISExpIdent `apply` parseContents `apply` parseContents
	    | "ISExpDomain" `isPrefixOf` t -> interior e $
		    return ISExpDomain `apply` parseContents `apply` parseContents
	}
    toContents v@(ISExpUnion aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(ISExpIntersection ac ad) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ac,
						     toContents ad])]
    toContents v@(ISExpDomain ae af) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents ae,
						     toContents af])]
    toContents v@(ISExpRange ag ah) =
	[mkElemC (showConstr 3 (toHType v)) (concat [toContents ag,
						     toContents ah])]
    toContents v@(ISExpJoin ai aj) =
	[mkElemC (showConstr 4 (toHType v)) (concat [toContents ai,
						     toContents aj])]
    toContents v@(ISExpIdent ak al) =
	[mkElemC (showConstr 5 (toHType v)) (concat [toContents ak,
						     toContents al])]

instance HTypeable IDecl where
    toHType v =
	Defined "IDecl" []
		[Constr "IDecl" [] [toHType aa,toHType ab,toHType ac,toHType ad]]
      where
	(IDecl aa ab ac ad) = v
instance XmlContent IDecl where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "IDecl" $
		return IDecl `apply` parseContents `apply` parseContents
			     `apply` parseContents `apply` parseContents
	}
    toContents v@(IDecl aa ab ac ad) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab,toContents ac,toContents ad])]

instance HTypeable IAExp where
    toHType v =
	Defined "IAExp" []
		[Constr "IEAdd" [] [toHType aa,toHType ab],
		 Constr "IESub" [] [toHType ac,toHType ad],
		 Constr "IEMul" [] [toHType ae,toHType af],
		 Constr "IECSetExp" [] [toHType ag],
		 Constr "IEASetExp" [] [toHType ah],Constr "IEInt" [] [toHType ai]]
      where
	(IEAdd aa ab) = v
	(IESub ac ad) = v
	(IEMul ae af) = v
	(IECSetExp ag) = v
	(IEASetExp ah) = v
	(IEInt ai) = v
instance XmlContent IAExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["IESub","IEMul","IEInt","IECSetExp","IEAdd","IEASetExp"]
	; case t of
	  _ | "IESub" `isPrefixOf` t -> interior e $
		    return IESub `apply` parseContents `apply` parseContents
	    | "IEMul" `isPrefixOf` t -> interior e $
		    return IEMul `apply` parseContents `apply` parseContents
	    | "IEInt" `isPrefixOf` t -> interior e $ fmap IEInt parseContents
	    | "IECSetExp" `isPrefixOf` t -> interior e $ fmap IECSetExp parseContents
	    | "IEAdd" `isPrefixOf` t -> interior e $
		    return IEAdd `apply` parseContents `apply` parseContents
	    | "IEASetExp" `isPrefixOf` t -> interior e $ fmap IEASetExp parseContents
	}
    toContents v@(IEAdd aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(IESub ac ad) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ac,
						     toContents ad])]
    toContents v@(IEMul ae af) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents ae,
						     toContents af])]
    toContents v@(IECSetExp ag) =
	[mkElemC (showConstr 3 (toHType v)) (toContents ag)]
    toContents v@(IEASetExp ah) =
	[mkElemC (showConstr 4 (toHType v)) (toContents ah)]
    toContents v@(IEInt ai) =
	[mkElemC (showConstr 5 (toHType v)) (toContents ai)]

--  Imported from other files :-
