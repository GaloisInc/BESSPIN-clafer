{-
 This file is part of the Clafer Translator (clafer).

 Copyright (C) 2010 Kacper Bak <http://gsd.uwaterloo.ca/kbak>

 clafer is free software: you can redistribute it and/or modify
 it under the terms of the GNU Lesser General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 clafer is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public License
 along with clafer. (See files COPYING and COPYING.LESSER.)  If not,
 see <http://www.gnu.org/licenses/>.
-}
module Generator.XmlHelp where

import Data.List (isPrefixOf)
import Text.XML.HaXml.XmlContent.Haskell
import Front.Absclafer
import Intermediate.Intclafer
{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "Front/Absclafer.hs" #-}
{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance HTypeable Ident where
    toHType v =
	Defined "Ident" [] [Constr "Ident" [] [toHType aa]]
      where
	(Ident aa) = v
instance XmlContent Ident where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "Ident" $
		fmap Ident parseContents
	}
    toContents v@(Ident aa) =
	[mkElemC (showConstr 0 (toHType v)) (toContents aa)]

instance HTypeable Clafer where
    toHType v =
	Defined "Clafer" []
		[Constr "Clafer" []
			[toHType aa,toHType ab,toHType ac,toHType ad,toHType ae,
			 toHType af]]
      where
	(Clafer aa ab ac ad ae af) = v
instance XmlContent Clafer where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "Clafer" $
		return Clafer `apply` parseContents `apply` parseContents
			      `apply` parseContents `apply` parseContents `apply` parseContents
			      `apply` parseContents
	}
    toContents v@(Clafer aa ab ac ad ae af) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab,toContents ac,toContents ad,
						     toContents ae,toContents af])]

instance HTypeable Constraint where
    toHType v =
	Defined "Constraint" [] [Constr "Constraint" [] [toHType aa]]
      where
	(Constraint aa) = v
instance XmlContent Constraint where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "Constraint" $
		fmap Constraint parseContents
	}
    toContents v@(Constraint aa) =
	[mkElemC (showConstr 0 (toHType v)) (toContents aa)]

instance HTypeable Abstract where
    toHType v =
	Defined "Abstract" []
		[Constr "AbstractEmpty" [] [],Constr "Abstract" [] []]
instance XmlContent Abstract where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["AbstractEmpty","Abstract"]
	; case t of
	  _ | "AbstractEmpty" `isPrefixOf` t -> interior e $ return AbstractEmpty
	    | "Abstract" `isPrefixOf` t -> interior e $ return Abstract
	}
    toContents v@AbstractEmpty =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@Abstract =
	[mkElemC (showConstr 1 (toHType v)) []]

instance HTypeable Elements where
    toHType v =
	Defined "Elements" []
		[Constr "ElementsEmpty" [] [],
		 Constr "ElementsList" [] [toHType aa]]
      where
	(ElementsList aa) = v
instance XmlContent Elements where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["ElementsList","ElementsEmpty"]
	; case t of
	  _ | "ElementsList" `isPrefixOf` t -> interior e $ fmap ElementsList parseContents
	    | "ElementsEmpty" `isPrefixOf` t -> interior e $ return ElementsEmpty
	}
    toContents v@ElementsEmpty =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@(ElementsList aa) =
	[mkElemC (showConstr 1 (toHType v)) (toContents aa)]

instance HTypeable ElementCl where
    toHType v =
	Defined "ElementCl" []
		[Constr "Subclafer" [] [toHType aa],
		 Constr "ClaferUse" [] [toHType ab,toHType ac,toHType ad],
		 Constr "Subconstraint" [] [toHType ae]]
      where
	(Subclafer aa) = v
	(ClaferUse ab ac ad) = v
	(Subconstraint ae) = v
instance XmlContent ElementCl where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["Subconstraint","Subclafer","ClaferUse"]
	; case t of
	  _ | "Subconstraint" `isPrefixOf` t -> interior e $ fmap Subconstraint parseContents
	    | "Subclafer" `isPrefixOf` t -> interior e $ fmap Subclafer parseContents
	    | "ClaferUse" `isPrefixOf` t -> interior e $
		    return ClaferUse `apply` parseContents `apply` parseContents
				     `apply` parseContents
	}
    toContents v@(Subclafer aa) =
	[mkElemC (showConstr 0 (toHType v)) (toContents aa)]
    toContents v@(ClaferUse ab ac ad) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ab,
						     toContents ac,toContents ad])]
    toContents v@(Subconstraint ae) =
	[mkElemC (showConstr 2 (toHType v)) (toContents ae)]

instance HTypeable Super where
    toHType v =
	Defined "Super" []
		[Constr "SuperEmpty" [] [],Constr "SuperColon" [] [toHType aa],
		 Constr "SuperExtends" [] [toHType ab],
		 Constr "SuperArrow" [] [toHType ac,toHType ad]]
      where
	(SuperColon aa) = v
	(SuperExtends ab) = v
	(SuperArrow ac ad) = v
instance XmlContent Super where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["SuperExtends","SuperEmpty","SuperColon","SuperArrow"]
	; case t of
	  _ | "SuperExtends" `isPrefixOf` t -> interior e $ fmap SuperExtends parseContents
	    | "SuperEmpty" `isPrefixOf` t -> interior e $ return SuperEmpty
	    | "SuperColon" `isPrefixOf` t -> interior e $ fmap SuperColon parseContents
	    | "SuperArrow" `isPrefixOf` t -> interior e $
		    return SuperArrow `apply` parseContents `apply` parseContents
	}
    toContents v@SuperEmpty =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@(SuperColon aa) =
	[mkElemC (showConstr 1 (toHType v)) (toContents aa)]
    toContents v@(SuperExtends ab) =
	[mkElemC (showConstr 2 (toHType v)) (toContents ab)]
    toContents v@(SuperArrow ac ad) =
	[mkElemC (showConstr 3 (toHType v)) (concat [toContents ac,
						     toContents ad])]

instance HTypeable GCard where
    toHType v =
	Defined "GCard" []
		[Constr "GCardEmpty" [] [],Constr "GCardXor" [] [],
		 Constr "GCardOr" [] [],Constr "GCardMux" [] [],
		 Constr "GCardOpt" [] [],Constr "GCardInterval" [] [toHType aa]]
      where
	(GCardInterval aa) = v
instance XmlContent GCard where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["GCardXor","GCardOr","GCardOpt","GCardMux","GCardInterval","GCardEmpty"]
	; case t of
	  _ | "GCardXor" `isPrefixOf` t -> interior e $ return GCardXor
	    | "GCardOr" `isPrefixOf` t -> interior e $ return GCardOr
	    | "GCardOpt" `isPrefixOf` t -> interior e $ return GCardOpt
	    | "GCardMux" `isPrefixOf` t -> interior e $ return GCardMux
	    | "GCardInterval" `isPrefixOf` t -> interior e $ fmap GCardInterval parseContents
	    | "GCardEmpty" `isPrefixOf` t -> interior e $ return GCardEmpty
	}
    toContents v@GCardEmpty =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@GCardXor =
	[mkElemC (showConstr 1 (toHType v)) []]
    toContents v@GCardOr =
	[mkElemC (showConstr 2 (toHType v)) []]
    toContents v@GCardMux =
	[mkElemC (showConstr 3 (toHType v)) []]
    toContents v@GCardOpt =
	[mkElemC (showConstr 4 (toHType v)) []]
    toContents v@(GCardInterval aa) =
	[mkElemC (showConstr 5 (toHType v)) (toContents aa)]

instance HTypeable Card where
    toHType v =
	Defined "Card" []
		[Constr "CardEmpty" [] [],Constr "CardLone" [] [],
		 Constr "CardSome" [] [],Constr "CardAny" [] [],
		 Constr "CardInterval" [] [toHType aa]]
      where
	(CardInterval aa) = v
instance XmlContent Card where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["CardSome","CardLone","CardInterval","CardEmpty","CardAny"]
	; case t of
	  _ | "CardSome" `isPrefixOf` t -> interior e $ return CardSome
	    | "CardLone" `isPrefixOf` t -> interior e $ return CardLone
	    | "CardInterval" `isPrefixOf` t -> interior e $ fmap CardInterval parseContents
	    | "CardEmpty" `isPrefixOf` t -> interior e $ return CardEmpty
	    | "CardAny" `isPrefixOf` t -> interior e $ return CardAny
	}
    toContents v@CardEmpty =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@CardLone =
	[mkElemC (showConstr 1 (toHType v)) []]
    toContents v@CardSome =
	[mkElemC (showConstr 2 (toHType v)) []]
    toContents v@CardAny =
	[mkElemC (showConstr 3 (toHType v)) []]
    toContents v@(CardInterval aa) =
	[mkElemC (showConstr 4 (toHType v)) (toContents aa)]

instance HTypeable GNCard where
    toHType v =
	Defined "GNCard" [] [Constr "GNCard" [] [toHType aa,toHType ab]]
      where
	(GNCard aa ab) = v
instance XmlContent GNCard where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "GNCard" $
		return GNCard `apply` parseContents `apply` parseContents
	}
    toContents v@(GNCard aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]

instance HTypeable NCard where
    toHType v =
	Defined "NCard" [] [Constr "NCard" [] [toHType aa,toHType ab]]
      where
	(NCard aa ab) = v
instance XmlContent NCard where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "NCard" $
		return NCard `apply` parseContents `apply` parseContents
	}
    toContents v@(NCard aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]

instance HTypeable ExInteger where
    toHType v =
	Defined "ExInteger" []
		[Constr "ExIntegerAst" [] [],Constr "ExIntegerNum" [] [toHType aa]]
      where
	(ExIntegerNum aa) = v
instance XmlContent ExInteger where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["ExIntegerNum","ExIntegerAst"]
	; case t of
	  _ | "ExIntegerNum" `isPrefixOf` t -> interior e $ fmap ExIntegerNum parseContents
	    | "ExIntegerAst" `isPrefixOf` t -> interior e $ return ExIntegerAst
	}
    toContents v@ExIntegerAst =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@(ExIntegerNum aa) =
	[mkElemC (showConstr 1 (toHType v)) (toContents aa)]

instance HTypeable Name where
    toHType v =
	Defined "Name" [] [Constr "Name" [] [toHType aa,toHType ab]]
      where
	(Name aa ab) = v
instance XmlContent Name where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "Name" $
		return Name `apply` parseContents `apply` parseContents
	}
    toContents v@(Name aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]

instance HTypeable LExp where
    toHType v =
	Defined "LExp" []
		[Constr "EIff" [] [toHType aa,toHType ab,toHType ac],
		 Constr "EImplies" [] [toHType ad,toHType ae,toHType af],
		 Constr "EImpliesElse" []
			[toHType ag,toHType ah,toHType ai,toHType aj]
		 ,Constr "EOr" [] [toHType ak,toHType al,toHType am],
		 Constr "EXor" [] [toHType an,toHType ao,toHType ap],
		 Constr "EAnd" [] [toHType aq,toHType ar,toHType as],
		 Constr "ENeg" [] [toHType at,toHType au],
		 Constr "ETerm" [] [toHType av]]
      where
	(EIff aa ab ac) = v
	(EImplies ad ae af) = v
	(EImpliesElse ag ah ai aj) = v
	(EOr ak al am) = v
	(EXor an ao ap) = v
	(EAnd aq ar as) = v
	(ENeg at au) = v
	(ETerm av) = v
instance XmlContent LExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["EXor","ETerm","EOr","ENeg","EImpliesElse","EImplies","EIff","EAnd"]
	; case t of
	  _ | "EXor" `isPrefixOf` t -> interior e $
		    return EXor `apply` parseContents `apply` parseContents
				`apply` parseContents
	    | "ETerm" `isPrefixOf` t -> interior e $ fmap ETerm parseContents
	    | "EOr" `isPrefixOf` t -> interior e $
		    return EOr `apply` parseContents `apply` parseContents
			       `apply` parseContents
	    | "ENeg" `isPrefixOf` t -> interior e $
		    return ENeg `apply` parseContents `apply` parseContents
	    | "EImpliesElse" `isPrefixOf` t -> interior e $
		    return EImpliesElse `apply` parseContents `apply` parseContents
					`apply` parseContents `apply` parseContents
	    | "EImplies" `isPrefixOf` t -> interior e $
		    return EImplies `apply` parseContents `apply` parseContents
				    `apply` parseContents
	    | "EIff" `isPrefixOf` t -> interior e $
		    return EIff `apply` parseContents `apply` parseContents
				`apply` parseContents
	    | "EAnd" `isPrefixOf` t -> interior e $
		    return EAnd `apply` parseContents `apply` parseContents
				`apply` parseContents
	}
    toContents v@(EIff aa ab ac) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab,toContents ac])]
    toContents v@(EImplies ad ae af) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ad,
						     toContents ae,toContents af])]
    toContents v@(EImpliesElse ag ah ai aj) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents ag,
						     toContents ah,toContents ai,toContents aj])]
    toContents v@(EOr ak al am) =
	[mkElemC (showConstr 3 (toHType v)) (concat [toContents ak,
						     toContents al,toContents am])]
    toContents v@(EXor an ao ap) =
	[mkElemC (showConstr 4 (toHType v)) (concat [toContents an,
						     toContents ao,toContents ap])]
    toContents v@(EAnd aq ar as) =
	[mkElemC (showConstr 5 (toHType v)) (concat [toContents aq,
						     toContents ar,toContents as])]
    toContents v@(ENeg at au) =
	[mkElemC (showConstr 6 (toHType v)) (concat [toContents at,
						     toContents au])]
    toContents v@(ETerm av) =
	[mkElemC (showConstr 7 (toHType v)) (toContents av)]

instance HTypeable Term where
    toHType v =
	Defined "Term" []
		[Constr "TermCmpExp" [] [toHType aa],
		 Constr "TermSet" [] [toHType ab],
		 Constr "TermQuantSet" [] [toHType ac,toHType ad],
		 Constr "TermQuantDeclExp" [] [toHType ae,toHType af]]
      where
	(TermCmpExp aa) = v
	(TermSet ab) = v
	(TermQuantSet ac ad) = v
	(TermQuantDeclExp ae af) = v
instance XmlContent Term where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["TermSet","TermQuantSet","TermQuantDeclExp","TermCmpExp"]
	; case t of
	  _ | "TermSet" `isPrefixOf` t -> interior e $ fmap TermSet parseContents
	    | "TermQuantSet" `isPrefixOf` t -> interior e $
		    return TermQuantSet `apply` parseContents `apply` parseContents
	    | "TermQuantDeclExp" `isPrefixOf` t -> interior e $
		    return TermQuantDeclExp `apply` parseContents `apply` parseContents
	    | "TermCmpExp" `isPrefixOf` t -> interior e $ fmap TermCmpExp parseContents
	}
    toContents v@(TermCmpExp aa) =
	[mkElemC (showConstr 0 (toHType v)) (toContents aa)]
    toContents v@(TermSet ab) =
	[mkElemC (showConstr 1 (toHType v)) (toContents ab)]
    toContents v@(TermQuantSet ac ad) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents ac,
						     toContents ad])]
    toContents v@(TermQuantDeclExp ae af) =
	[mkElemC (showConstr 3 (toHType v)) (concat [toContents ae,
						     toContents af])]

instance HTypeable Iff where
    toHType v =
	Defined "Iff" [] [Constr "Iff" [] []]
instance XmlContent Iff where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "Iff" $
		return Iff
	}
    toContents v@Iff =
	[mkElemC (showConstr 0 (toHType v)) []]

instance HTypeable Implies where
    toHType v =
	Defined "Implies" [] [Constr "Implies" [] []]
instance XmlContent Implies where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "Implies" $
		return Implies
	}
    toContents v@Implies =
	[mkElemC (showConstr 0 (toHType v)) []]

instance HTypeable And where
    toHType v =
	Defined "And" [] [Constr "And" [] []]
instance XmlContent And where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "And" $
		return And
	}
    toContents v@And =
	[mkElemC (showConstr 0 (toHType v)) []]

instance HTypeable Xor where
    toHType v =
	Defined "Xor" [] [Constr "Xor" [] []]
instance XmlContent Xor where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "Xor" $
		return Xor
	}
    toContents v@Xor =
	[mkElemC (showConstr 0 (toHType v)) []]

instance HTypeable Or where
    toHType v =
	Defined "Or" [] [Constr "Or" [] []]
instance XmlContent Or where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "Or" $
		return Or
	}
    toContents v@Or =
	[mkElemC (showConstr 0 (toHType v)) []]

instance HTypeable Neg where
    toHType v =
	Defined "Neg" [] [Constr "Neg" [] []]
instance XmlContent Neg where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "Neg" $
		return Neg
	}
    toContents v@Neg =
	[mkElemC (showConstr 0 (toHType v)) []]

instance HTypeable CmpExp where
    toHType v =
	Defined "CmpExp" []
		[Constr "ELt" [] [toHType aa,toHType ab],
		 Constr "EGt" [] [toHType ac,toHType ad],
		 Constr "EREq" [] [toHType ae,toHType af],
		 Constr "EEq" [] [toHType ag,toHType ah],
		 Constr "ELte" [] [toHType ai,toHType aj],
		 Constr "EGte" [] [toHType ak,toHType al],
		 Constr "ENeq" [] [toHType am,toHType an],
		 Constr "ERNeq" [] [toHType ao,toHType ap],
		 Constr "EIn" [] [toHType aq,toHType ar],
		 Constr "ENin" [] [toHType as,toHType at]]
      where
	(ELt aa ab) = v
	(EGt ac ad) = v
	(EREq ae af) = v
	(EEq ag ah) = v
	(ELte ai aj) = v
	(EGte ak al) = v
	(ENeq am an) = v
	(ERNeq ao ap) = v
	(EIn aq ar) = v
	(ENin as at) = v
instance XmlContent CmpExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["ERNeq","EREq","ENin","ENeq","ELte","ELt","EIn","EGte","EGt","EEq"]
	; case t of
	  _ | "ERNeq" `isPrefixOf` t -> interior e $
		    return ERNeq `apply` parseContents `apply` parseContents
	    | "EREq" `isPrefixOf` t -> interior e $
		    return EREq `apply` parseContents `apply` parseContents
	    | "ENin" `isPrefixOf` t -> interior e $
		    return ENin `apply` parseContents `apply` parseContents
	    | "ENeq" `isPrefixOf` t -> interior e $
		    return ENeq `apply` parseContents `apply` parseContents
	    | "ELte" `isPrefixOf` t -> interior e $
		    return ELte `apply` parseContents `apply` parseContents
	    | "ELt" `isPrefixOf` t -> interior e $
		    return ELt `apply` parseContents `apply` parseContents
	    | "EIn" `isPrefixOf` t -> interior e $
		    return EIn `apply` parseContents `apply` parseContents
	    | "EGte" `isPrefixOf` t -> interior e $
		    return EGte `apply` parseContents `apply` parseContents
	    | "EGt" `isPrefixOf` t -> interior e $
		    return EGt `apply` parseContents `apply` parseContents
	    | "EEq" `isPrefixOf` t -> interior e $
		    return EEq `apply` parseContents `apply` parseContents
	}
    toContents v@(ELt aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(EGt ac ad) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ac,
						     toContents ad])]
    toContents v@(EREq ae af) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents ae,
						     toContents af])]
    toContents v@(EEq ag ah) =
	[mkElemC (showConstr 3 (toHType v)) (concat [toContents ag,
						     toContents ah])]
    toContents v@(ELte ai aj) =
	[mkElemC (showConstr 4 (toHType v)) (concat [toContents ai,
						     toContents aj])]
    toContents v@(EGte ak al) =
	[mkElemC (showConstr 5 (toHType v)) (concat [toContents ak,
						     toContents al])]
    toContents v@(ENeq am an) =
	[mkElemC (showConstr 6 (toHType v)) (concat [toContents am,
						     toContents an])]
    toContents v@(ERNeq ao ap) =
	[mkElemC (showConstr 7 (toHType v)) (concat [toContents ao,
						     toContents ap])]
    toContents v@(EIn aq ar) =
	[mkElemC (showConstr 8 (toHType v)) (concat [toContents aq,
						     toContents ar])]
    toContents v@(ENin as at) =
	[mkElemC (showConstr 9 (toHType v)) (concat [toContents as,
						     toContents at])]

instance HTypeable Exp where
    toHType v =
	Defined "Exp" []
		[Constr "ENumExp" [] [toHType aa],Constr "EStrExp" [] [toHType ab]]
      where
	(ENumExp aa) = v
	(EStrExp ab) = v
instance XmlContent Exp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["EStrExp","ENumExp"]
	; case t of
	  _ | "EStrExp" `isPrefixOf` t -> interior e $ fmap EStrExp parseContents
	    | "ENumExp" `isPrefixOf` t -> interior e $ fmap ENumExp parseContents
	}
    toContents v@(ENumExp aa) =
	[mkElemC (showConstr 0 (toHType v)) (toContents aa)]
    toContents v@(EStrExp ab) =
	[mkElemC (showConstr 1 (toHType v)) (toContents ab)]

instance HTypeable Quant where
    toHType v =
	Defined "Quant" []
		[Constr "QuantNo" [] [],Constr "QuantLone" [] [],
		 Constr "QuantOne" [] [],Constr "QuantSome" [] []]
instance XmlContent Quant where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["QuantSome","QuantOne","QuantNo","QuantLone"]
	; case t of
	  _ | "QuantSome" `isPrefixOf` t -> interior e $ return QuantSome
	    | "QuantOne" `isPrefixOf` t -> interior e $ return QuantOne
	    | "QuantNo" `isPrefixOf` t -> interior e $ return QuantNo
	    | "QuantLone" `isPrefixOf` t -> interior e $ return QuantLone
	}
    toContents v@QuantNo =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@QuantLone =
	[mkElemC (showConstr 1 (toHType v)) []]
    toContents v@QuantOne =
	[mkElemC (showConstr 2 (toHType v)) []]
    toContents v@QuantSome =
	[mkElemC (showConstr 3 (toHType v)) []]

instance HTypeable ExQuant where
    toHType v =
	Defined "ExQuant" []
		[Constr "ExQuantAll" [] [],Constr "ExQuantQuant" [] [toHType aa]]
      where
	(ExQuantQuant aa) = v
instance XmlContent ExQuant where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["ExQuantQuant","ExQuantAll"]
	; case t of
	  _ | "ExQuantQuant" `isPrefixOf` t -> interior e $ fmap ExQuantQuant parseContents
	    | "ExQuantAll" `isPrefixOf` t -> interior e $ return ExQuantAll
	}
    toContents v@ExQuantAll =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@(ExQuantQuant aa) =
	[mkElemC (showConstr 1 (toHType v)) (toContents aa)]

instance HTypeable SExp where
    toHType v =
	Defined "SExp" []
		[Constr "SExpUnion" [] [toHType aa,toHType ab],
		 Constr "SExpIntersection" [] [toHType ac,toHType ad],
		 Constr "SExpDomain" [] [toHType ae,toHType af],
		 Constr "SExpRange" [] [toHType ag,toHType ah],
		 Constr "SExpJoin" [] [toHType ai,toHType aj],
		 Constr "SExpIdent" [] [toHType ak]]
      where
	(SExpUnion aa ab) = v
	(SExpIntersection ac ad) = v
	(SExpDomain ae af) = v
	(SExpRange ag ah) = v
	(SExpJoin ai aj) = v
	(SExpIdent ak) = v
instance XmlContent SExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["SExpUnion","SExpRange","SExpJoin","SExpIntersection","SExpIdent","SExpDomain"]
	; case t of
	  _ | "SExpUnion" `isPrefixOf` t -> interior e $
		    return SExpUnion `apply` parseContents `apply` parseContents
	    | "SExpRange" `isPrefixOf` t -> interior e $
		    return SExpRange `apply` parseContents `apply` parseContents
	    | "SExpJoin" `isPrefixOf` t -> interior e $
		    return SExpJoin `apply` parseContents `apply` parseContents
	    | "SExpIntersection" `isPrefixOf` t -> interior e $
		    return SExpIntersection `apply` parseContents `apply` parseContents
	    | "SExpIdent" `isPrefixOf` t -> interior e $ fmap SExpIdent parseContents
	    | "SExpDomain" `isPrefixOf` t -> interior e $
		    return SExpDomain `apply` parseContents `apply` parseContents
	}
    toContents v@(SExpUnion aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(SExpIntersection ac ad) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ac,
						     toContents ad])]
    toContents v@(SExpDomain ae af) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents ae,
						     toContents af])]
    toContents v@(SExpRange ag ah) =
	[mkElemC (showConstr 3 (toHType v)) (concat [toContents ag,
						     toContents ah])]
    toContents v@(SExpJoin ai aj) =
	[mkElemC (showConstr 4 (toHType v)) (concat [toContents ai,
						     toContents aj])]
    toContents v@(SExpIdent ak) =
	[mkElemC (showConstr 5 (toHType v)) (toContents ak)]

instance HTypeable Decl where
    toHType v =
	Defined "Decl" []
		[Constr "Decl" [] [toHType aa,toHType ab,toHType ac,toHType ad]]
      where
	(Decl aa ab ac ad) = v
instance XmlContent Decl where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "Decl" $
		return Decl `apply` parseContents `apply` parseContents
			    `apply` parseContents `apply` parseContents
	}
    toContents v@(Decl aa ab ac ad) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab,toContents ac,toContents ad])]

instance HTypeable Disj where
    toHType v =
	Defined "Disj" [] [Constr "DisjEmpty" [] [],Constr "Disj" [] []]
instance XmlContent Disj where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["DisjEmpty","Disj"]
	; case t of
	  _ | "DisjEmpty" `isPrefixOf` t -> interior e $ return DisjEmpty
	    | "Disj" `isPrefixOf` t -> interior e $ return Disj
	}
    toContents v@DisjEmpty =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@Disj =
	[mkElemC (showConstr 1 (toHType v)) []]

instance HTypeable AExp where
    toHType v =
	Defined "AExp" []
		[Constr "EAdd" [] [toHType aa,toHType ab],
		 Constr "ESub" [] [toHType ac,toHType ad],
		 Constr "EMul" [] [toHType ae,toHType af],
		 Constr "ECSetExp" [] [toHType ag],Constr "EASetExp" [] [toHType ah]
		 ,Constr "EInt" [] [toHType ai]]
      where
	(EAdd aa ab) = v
	(ESub ac ad) = v
	(EMul ae af) = v
	(ECSetExp ag) = v
	(EASetExp ah) = v
	(EInt ai) = v
instance XmlContent AExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["ESub","EMul","EInt","ECSetExp","EAdd","EASetExp"]
	; case t of
	  _ | "ESub" `isPrefixOf` t -> interior e $
		    return ESub `apply` parseContents `apply` parseContents
	    | "EMul" `isPrefixOf` t -> interior e $
		    return EMul `apply` parseContents `apply` parseContents
	    | "EInt" `isPrefixOf` t -> interior e $ fmap EInt parseContents
	    | "ECSetExp" `isPrefixOf` t -> interior e $ fmap ECSetExp parseContents
	    | "EAdd" `isPrefixOf` t -> interior e $
		    return EAdd `apply` parseContents `apply` parseContents
	    | "EASetExp" `isPrefixOf` t -> interior e $ fmap EASetExp parseContents
	}
    toContents v@(EAdd aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(ESub ac ad) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ac,
						     toContents ad])]
    toContents v@(EMul ae af) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents ae,
						     toContents af])]
    toContents v@(ECSetExp ag) =
	[mkElemC (showConstr 3 (toHType v)) (toContents ag)]
    toContents v@(EASetExp ah) =
	[mkElemC (showConstr 4 (toHType v)) (toContents ah)]
    toContents v@(EInt ai) =
	[mkElemC (showConstr 5 (toHType v)) (toContents ai)]

instance HTypeable StrExp where
    toHType v =
	Defined "StrExp" []
		[Constr "EConc" [] [toHType aa,toHType ab],
		 Constr "EStr" [] [toHType ac]]
      where
	(EConc aa ab) = v
	(EStr ac) = v
instance XmlContent StrExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["EStr","EConc"]
	; case t of
	  _ | "EStr" `isPrefixOf` t -> interior e $ fmap EStr parseContents
	    | "EConc" `isPrefixOf` t -> interior e $
		    return EConc `apply` parseContents `apply` parseContents
	}
    toContents v@(EConc aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(EStr ac) =
	[mkElemC (showConstr 1 (toHType v)) (toContents ac)]

instance HTypeable ModId where
    toHType v =
	Defined "ModId" [] [Constr "ModIdIdent" [] [toHType aa]]
      where
	(ModIdIdent aa) = v
instance XmlContent ModId where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "ModIdIdent" $
		fmap ModIdIdent parseContents
	}
    toContents v@(ModIdIdent aa) =
	[mkElemC (showConstr 0 (toHType v)) (toContents aa)]

instance HTypeable LocId where
    toHType v =
	Defined "LocId" [] [Constr "LocIdIdent" [] [toHType aa]]
      where
	(LocIdIdent aa) = v
instance XmlContent LocId where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "LocIdIdent" $
		fmap LocIdIdent parseContents
	}
    toContents v@(LocIdIdent aa) =
	[mkElemC (showConstr 0 (toHType v)) (toContents aa)]

--  Imported from other files :-
{- Generated by DrIFT (Automatic class derivations for Haskell) -}
{-# LINE 1 "Intermediate/Intclafer.hs" #-}
{-* Generated by DrIFT : Look, but Don't Touch. *-}
instance HTypeable EType where
    toHType v =
	Defined "EType" []
		[Constr "TAExp" [] [],Constr "TSExp" [] [],Constr "TSAExp" [] []]
instance XmlContent EType where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["TSExp","TSAExp","TAExp"]
	; case t of
	  _ | "TSExp" `isPrefixOf` t -> interior e $ return TSExp
	    | "TSAExp" `isPrefixOf` t -> interior e $ return TSAExp
	    | "TAExp" `isPrefixOf` t -> interior e $ return TAExp
	}
    toContents v@TAExp =
	[mkElemC (showConstr 0 (toHType v)) []]
    toContents v@TSExp =
	[mkElemC (showConstr 1 (toHType v)) []]
    toContents v@TSAExp =
	[mkElemC (showConstr 2 (toHType v)) []]

instance HTypeable IDeclaration where
    toHType v =
	Defined "IDeclaration" []
		[Constr "IClaferDecl" [] [toHType aa],
		 Constr "IConstDecl" [] [toHType ab]]
      where
	(IClaferDecl aa) = v
	(IConstDecl ab) = v
instance XmlContent IDeclaration where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["IConstDecl","IClaferDecl"]
	; case t of
	  _ | "IConstDecl" `isPrefixOf` t -> interior e $ fmap IConstDecl parseContents
	    | "IClaferDecl" `isPrefixOf` t -> interior e $ fmap IClaferDecl parseContents
	}
    toContents v@(IClaferDecl aa) =
	[mkElemC (showConstr 0 (toHType v)) (toContents aa)]
    toContents v@(IConstDecl ab) =
	[mkElemC (showConstr 1 (toHType v)) (toContents ab)]

instance HTypeable IClafer where
    toHType v =
	Defined "IClafer" []
		[Constr "IClafer" []
			[toHType aa,toHType ab,toHType ac,toHType ad,toHType ae,toHType af,
			 toHType ag,toHType ah]]
      where
	(IClafer aa ab ac ad ae af ag ah) = v
instance XmlContent IClafer where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "IClafer" $
		return IClafer `apply` parseContents `apply` parseContents
			       `apply` parseContents `apply` parseContents `apply` parseContents
			       `apply` parseContents `apply` parseContents `apply` parseContents
	}
    toContents v@(IClafer aa ab ac ad ae af ag ah) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab,toContents ac,toContents ad,
						     toContents ae,toContents af,toContents ag,
						     toContents ah])]

instance HTypeable IElement where
    toHType v =
	Defined "IElement" []
		[Constr "ISubclafer" [] [toHType aa],
		 Constr "ISubconstraint" [] [toHType ab]]
      where
	(ISubclafer aa) = v
	(ISubconstraint ab) = v
instance XmlContent IElement where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["ISubconstraint","ISubclafer"]
	; case t of
	  _ | "ISubconstraint" `isPrefixOf` t -> interior e $ fmap ISubconstraint parseContents
	    | "ISubclafer" `isPrefixOf` t -> interior e $ fmap ISubclafer parseContents
	}
    toContents v@(ISubclafer aa) =
	[mkElemC (showConstr 0 (toHType v)) (toContents aa)]
    toContents v@(ISubconstraint ab) =
	[mkElemC (showConstr 1 (toHType v)) (toContents ab)]

instance HTypeable ISuper where
    toHType v =
	Defined "ISuper" [] [Constr "ISuper" [] [toHType aa,toHType ab]]
      where
	(ISuper aa ab) = v
instance XmlContent ISuper where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "ISuper" $
		return ISuper `apply` parseContents `apply` parseContents
	}
    toContents v@(ISuper aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]

instance HTypeable IGCard where
    toHType v =
	Defined "IGCard" [] [Constr "IGCard" [] [toHType aa,toHType ab]]
      where
	(IGCard aa ab) = v
instance XmlContent IGCard where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "IGCard" $
		return IGCard `apply` parseContents `apply` parseContents
	}
    toContents v@(IGCard aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]

instance HTypeable ILExp where
    toHType v =
	Defined "ILExp" []
		[Constr "IEIff" [] [toHType aa,toHType ab],
		 Constr "IEImpliesElse" [] [toHType ac,toHType ad,toHType ae],
		 Constr "IEOr" [] [toHType af,toHType ag],
		 Constr "IEXor" [] [toHType ah,toHType ai],
		 Constr "IEAnd" [] [toHType aj,toHType ak],
		 Constr "IENeg" [] [toHType al],Constr "IETerm" [] [toHType am]]
      where
	(IEIff aa ab) = v
	(IEImpliesElse ac ad ae) = v
	(IEOr af ag) = v
	(IEXor ah ai) = v
	(IEAnd aj ak) = v
	(IENeg al) = v
	(IETerm am) = v
instance XmlContent ILExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["IEXor","IETerm","IEOr","IENeg","IEImpliesElse","IEIff","IEAnd"]
	; case t of
	  _ | "IEXor" `isPrefixOf` t -> interior e $
		    return IEXor `apply` parseContents `apply` parseContents
	    | "IETerm" `isPrefixOf` t -> interior e $ fmap IETerm parseContents
	    | "IEOr" `isPrefixOf` t -> interior e $
		    return IEOr `apply` parseContents `apply` parseContents
	    | "IENeg" `isPrefixOf` t -> interior e $ fmap IENeg parseContents
	    | "IEImpliesElse" `isPrefixOf` t -> interior e $
		    return IEImpliesElse `apply` parseContents `apply` parseContents
					 `apply` parseContents
	    | "IEIff" `isPrefixOf` t -> interior e $
		    return IEIff `apply` parseContents `apply` parseContents
	    | "IEAnd" `isPrefixOf` t -> interior e $
		    return IEAnd `apply` parseContents `apply` parseContents
	}
    toContents v@(IEIff aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(IEImpliesElse ac ad ae) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ac,
						     toContents ad,toContents ae])]
    toContents v@(IEOr af ag) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents af,
						     toContents ag])]
    toContents v@(IEXor ah ai) =
	[mkElemC (showConstr 3 (toHType v)) (concat [toContents ah,
						     toContents ai])]
    toContents v@(IEAnd aj ak) =
	[mkElemC (showConstr 4 (toHType v)) (concat [toContents aj,
						     toContents ak])]
    toContents v@(IENeg al) =
	[mkElemC (showConstr 5 (toHType v)) (toContents al)]
    toContents v@(IETerm am) =
	[mkElemC (showConstr 6 (toHType v)) (toContents am)]

instance HTypeable ITerm where
    toHType v =
	Defined "ITerm" []
		[Constr "ITermCmpExp" [] [toHType aa,toHType ab],
		 Constr "ITermQuantSet" [] [toHType ac,toHType ad],
		 Constr "ITermQuantDeclExp" [] [toHType ae,toHType af]]
      where
	(ITermCmpExp aa ab) = v
	(ITermQuantSet ac ad) = v
	(ITermQuantDeclExp ae af) = v
instance XmlContent ITerm where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["ITermQuantSet","ITermQuantDeclExp","ITermCmpExp"]
	; case t of
	  _ | "ITermQuantSet" `isPrefixOf` t -> interior e $
		    return ITermQuantSet `apply` parseContents `apply` parseContents
	    | "ITermQuantDeclExp" `isPrefixOf` t -> interior e $
		    return ITermQuantDeclExp `apply` parseContents
					     `apply` parseContents
	    | "ITermCmpExp" `isPrefixOf` t -> interior e $
		    return ITermCmpExp `apply` parseContents `apply` parseContents
	}
    toContents v@(ITermCmpExp aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(ITermQuantSet ac ad) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ac,
						     toContents ad])]
    toContents v@(ITermQuantDeclExp ae af) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents ae,
						     toContents af])]

instance HTypeable ICmpExp where
    toHType v =
	Defined "ICmpExp" []
		[Constr "IELt" [] [toHType aa,toHType ab],
		 Constr "IEGt" [] [toHType ac,toHType ad],
		 Constr "IEREq" [] [toHType ae,toHType af],
		 Constr "IEEq" [] [toHType ag,toHType ah],
		 Constr "IELte" [] [toHType ai,toHType aj],
		 Constr "IEGte" [] [toHType ak,toHType al],
		 Constr "IENeq" [] [toHType am,toHType an],
		 Constr "IERNeq" [] [toHType ao,toHType ap],
		 Constr "IEIn" [] [toHType aq,toHType ar],
		 Constr "IENin" [] [toHType as,toHType at]]
      where
	(IELt aa ab) = v
	(IEGt ac ad) = v
	(IEREq ae af) = v
	(IEEq ag ah) = v
	(IELte ai aj) = v
	(IEGte ak al) = v
	(IENeq am an) = v
	(IERNeq ao ap) = v
	(IEIn aq ar) = v
	(IENin as at) = v
instance XmlContent ICmpExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["IERNeq","IEREq","IENin","IENeq","IELte","IELt","IEIn","IEGte","IEGt","IEEq"]
	; case t of
	  _ | "IERNeq" `isPrefixOf` t -> interior e $
		    return IERNeq `apply` parseContents `apply` parseContents
	    | "IEREq" `isPrefixOf` t -> interior e $
		    return IEREq `apply` parseContents `apply` parseContents
	    | "IENin" `isPrefixOf` t -> interior e $
		    return IENin `apply` parseContents `apply` parseContents
	    | "IENeq" `isPrefixOf` t -> interior e $
		    return IENeq `apply` parseContents `apply` parseContents
	    | "IELte" `isPrefixOf` t -> interior e $
		    return IELte `apply` parseContents `apply` parseContents
	    | "IELt" `isPrefixOf` t -> interior e $
		    return IELt `apply` parseContents `apply` parseContents
	    | "IEIn" `isPrefixOf` t -> interior e $
		    return IEIn `apply` parseContents `apply` parseContents
	    | "IEGte" `isPrefixOf` t -> interior e $
		    return IEGte `apply` parseContents `apply` parseContents
	    | "IEGt" `isPrefixOf` t -> interior e $
		    return IEGt `apply` parseContents `apply` parseContents
	    | "IEEq" `isPrefixOf` t -> interior e $
		    return IEEq `apply` parseContents `apply` parseContents
	}
    toContents v@(IELt aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(IEGt ac ad) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ac,
						     toContents ad])]
    toContents v@(IEREq ae af) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents ae,
						     toContents af])]
    toContents v@(IEEq ag ah) =
	[mkElemC (showConstr 3 (toHType v)) (concat [toContents ag,
						     toContents ah])]
    toContents v@(IELte ai aj) =
	[mkElemC (showConstr 4 (toHType v)) (concat [toContents ai,
						     toContents aj])]
    toContents v@(IEGte ak al) =
	[mkElemC (showConstr 5 (toHType v)) (concat [toContents ak,
						     toContents al])]
    toContents v@(IENeq am an) =
	[mkElemC (showConstr 6 (toHType v)) (concat [toContents am,
						     toContents an])]
    toContents v@(IERNeq ao ap) =
	[mkElemC (showConstr 7 (toHType v)) (concat [toContents ao,
						     toContents ap])]
    toContents v@(IEIn aq ar) =
	[mkElemC (showConstr 8 (toHType v)) (concat [toContents aq,
						     toContents ar])]
    toContents v@(IENin as at) =
	[mkElemC (showConstr 9 (toHType v)) (concat [toContents as,
						     toContents at])]

instance HTypeable IExp where
    toHType v =
	Defined "IExp" []
		[Constr "IENumExp" [] [toHType aa],
		 Constr "IEStrExp" [] [toHType ab]]
      where
	(IENumExp aa) = v
	(IEStrExp ab) = v
instance XmlContent IExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["IEStrExp","IENumExp"]
	; case t of
	  _ | "IEStrExp" `isPrefixOf` t -> interior e $ fmap IEStrExp parseContents
	    | "IENumExp" `isPrefixOf` t -> interior e $ fmap IENumExp parseContents
	}
    toContents v@(IENumExp aa) =
	[mkElemC (showConstr 0 (toHType v)) (toContents aa)]
    toContents v@(IEStrExp ab) =
	[mkElemC (showConstr 1 (toHType v)) (toContents ab)]

instance HTypeable ISExp where
    toHType v =
	Defined "ISExp" []
		[Constr "ISExpUnion" [] [toHType aa,toHType ab],
		 Constr "ISExpIntersection" [] [toHType ac,toHType ad],
		 Constr "ISExpDomain" [] [toHType ae,toHType af],
		 Constr "ISExpRange" [] [toHType ag,toHType ah],
		 Constr "ISExpJoin" [] [toHType ai,toHType aj],
		 Constr "ISExpIdent" [] [toHType ak,toHType al]]
      where
	(ISExpUnion aa ab) = v
	(ISExpIntersection ac ad) = v
	(ISExpDomain ae af) = v
	(ISExpRange ag ah) = v
	(ISExpJoin ai aj) = v
	(ISExpIdent ak al) = v
instance XmlContent ISExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["ISExpUnion","ISExpRange","ISExpJoin","ISExpIntersection","ISExpIdent","ISExpDomain"]
	; case t of
	  _ | "ISExpUnion" `isPrefixOf` t -> interior e $
		    return ISExpUnion `apply` parseContents `apply` parseContents
	    | "ISExpRange" `isPrefixOf` t -> interior e $
		    return ISExpRange `apply` parseContents `apply` parseContents
	    | "ISExpJoin" `isPrefixOf` t -> interior e $
		    return ISExpJoin `apply` parseContents `apply` parseContents
	    | "ISExpIntersection" `isPrefixOf` t -> interior e $
		    return ISExpIntersection `apply` parseContents
					     `apply` parseContents
	    | "ISExpIdent" `isPrefixOf` t -> interior e $
		    return ISExpIdent `apply` parseContents `apply` parseContents
	    | "ISExpDomain" `isPrefixOf` t -> interior e $
		    return ISExpDomain `apply` parseContents `apply` parseContents
	}
    toContents v@(ISExpUnion aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(ISExpIntersection ac ad) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ac,
						     toContents ad])]
    toContents v@(ISExpDomain ae af) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents ae,
						     toContents af])]
    toContents v@(ISExpRange ag ah) =
	[mkElemC (showConstr 3 (toHType v)) (concat [toContents ag,
						     toContents ah])]
    toContents v@(ISExpJoin ai aj) =
	[mkElemC (showConstr 4 (toHType v)) (concat [toContents ai,
						     toContents aj])]
    toContents v@(ISExpIdent ak al) =
	[mkElemC (showConstr 5 (toHType v)) (concat [toContents ak,
						     toContents al])]

instance HTypeable IDecl where
    toHType v =
	Defined "IDecl" []
		[Constr "IDecl" [] [toHType aa,toHType ab,toHType ac,toHType ad]]
      where
	(IDecl aa ab ac ad) = v
instance XmlContent IDecl where
    parseContents = do
	{ inElementWith (flip isPrefixOf) "IDecl" $
		return IDecl `apply` parseContents `apply` parseContents
			     `apply` parseContents `apply` parseContents
	}
    toContents v@(IDecl aa ab ac ad) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab,toContents ac,toContents ad])]

instance HTypeable IAExp where
    toHType v =
	Defined "IAExp" []
		[Constr "IEAdd" [] [toHType aa,toHType ab],
		 Constr "IESub" [] [toHType ac,toHType ad],
		 Constr "IEMul" [] [toHType ae,toHType af],
		 Constr "IECSetExp" [] [toHType ag],
		 Constr "IEASetExp" [] [toHType ah],Constr "IEInt" [] [toHType ai]]
      where
	(IEAdd aa ab) = v
	(IESub ac ad) = v
	(IEMul ae af) = v
	(IECSetExp ag) = v
	(IEASetExp ah) = v
	(IEInt ai) = v
instance XmlContent IAExp where
    parseContents = do
	{ e@(Elem t _ _) <- elementWith (flip isPrefixOf) ["IESub","IEMul","IEInt","IECSetExp","IEAdd","IEASetExp"]
	; case t of
	  _ | "IESub" `isPrefixOf` t -> interior e $
		    return IESub `apply` parseContents `apply` parseContents
	    | "IEMul" `isPrefixOf` t -> interior e $
		    return IEMul `apply` parseContents `apply` parseContents
	    | "IEInt" `isPrefixOf` t -> interior e $ fmap IEInt parseContents
	    | "IECSetExp" `isPrefixOf` t -> interior e $ fmap IECSetExp parseContents
	    | "IEAdd" `isPrefixOf` t -> interior e $
		    return IEAdd `apply` parseContents `apply` parseContents
	    | "IEASetExp" `isPrefixOf` t -> interior e $ fmap IEASetExp parseContents
	}
    toContents v@(IEAdd aa ab) =
	[mkElemC (showConstr 0 (toHType v)) (concat [toContents aa,
						     toContents ab])]
    toContents v@(IESub ac ad) =
	[mkElemC (showConstr 1 (toHType v)) (concat [toContents ac,
						     toContents ad])]
    toContents v@(IEMul ae af) =
	[mkElemC (showConstr 2 (toHType v)) (concat [toContents ae,
						     toContents af])]
    toContents v@(IECSetExp ag) =
	[mkElemC (showConstr 3 (toHType v)) (toContents ag)]
    toContents v@(IEASetExp ah) =
	[mkElemC (showConstr 4 (toHType v)) (toContents ah)]
    toContents v@(IEInt ai) =
	[mkElemC (showConstr 5 (toHType v)) (toContents ai)]

--  Imported from other files :-
